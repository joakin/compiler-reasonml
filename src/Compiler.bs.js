// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function map(result, fn) {
  if (result.tag) {
    return /* Err */Block.__(1, [result[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._1(fn, result[0])]);
  }
}

function map2(r1, r2, fn) {
  if (r1.tag) {
    return /* Err */Block.__(1, [r1[0]]);
  } else if (r2.tag) {
    return /* Err */Block.__(1, [r2[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._2(fn, r1[0], r2[0])]);
  }
}

function andThen(r1, fn) {
  if (r1.tag) {
    return /* Err */Block.__(1, [r1[0]]);
  } else {
    return Curry._1(fn, r1[0]);
  }
}

var Result = /* module */[
  /* map */map,
  /* map2 */map2,
  /* andThen */andThen
];

var Ast = /* module */[/* example : Fn */Block.__(3, [/* record */[
        /* param */"x",
        /* body : If */Block.__(5, [/* record */[
              /* cond : Var */Block.__(2, ["x"]),
              /* trueBranch : Float */Block.__(0, [1]),
              /* falseBranch : Call */Block.__(4, [/* record */[
                    /* fn : Var */Block.__(2, ["f"]),
                    /* arg : Var */Block.__(2, ["x"])
                  ]])
            ]])
      ]])];

function contains(_t, name) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          return /* false */0;
      case 1 : 
          return +(t[0] === name);
      case 2 : 
          var match = t[0];
          if (contains(match[/* from */0], name)) {
            return /* true */1;
          } else {
            _t = match[/* to_ */1];
            continue ;
            
          }
      
    }
  };
}

function toString(t) {
  switch (t.tag | 0) {
    case 0 : 
    case 1 : 
        return t[0];
    case 2 : 
        var match = t[0];
        return "(" + (toString(match[/* from */0]) + (" -> " + (toString(match[/* to_ */1]) + ")")));
    
  }
}

var Type = /* module */[
  /* contains */contains,
  /* toString */toString
];

function newTVar(ctx) {
  var tvar = /* Var */Block.__(1, ["T" + Pervasives.string_of_float(ctx[/* nextTVar */0])]);
  ctx[0] += 1;
  return tvar;
}

function newBinding(ctx, name, tvar) {
  return /* record */[
          /* nextTVar */ctx[/* nextTVar */0],
          /* env */Belt_MapString.set(ctx[/* env */1], name, tvar)
        ];
}

function mapEnv(ctx, fn) {
  return /* record */[
          /* nextTVar */ctx[/* nextTVar */0],
          /* env */Belt_MapString.map(ctx[/* env */1], Curry.__1(fn))
        ];
}

var Context = /* module */[
  /* get */Belt_MapString.get,
  /* newTVar */newTVar,
  /* newBinding */newBinding,
  /* mapEnv */mapEnv
];

function toString$1(m) {
  return "{" + ($$Array.fold_left((function (r, s) {
                  return r + (" " + s);
                }), "", $$Array.map((function (param) {
                      return param[0] + (": " + (toString(param[1]) + ","));
                    }), Belt_MapString.toArray(m))) + "}");
}

function applySubstitutionToType(subst, type_) {
  switch (type_.tag | 0) {
    case 0 : 
        return type_;
    case 1 : 
        var match = Belt_MapString.get(subst, type_[0]);
        if (match) {
          return match[0];
        } else {
          return type_;
        }
    case 2 : 
        var match$1 = type_[0];
        return /* Fun */Block.__(2, [/* record */[
                    /* from */applySubstitutionToType(subst, match$1[/* from */0]),
                    /* to_ */applySubstitutionToType(subst, match$1[/* to_ */1])
                  ]]);
    
  }
}

function applySubstitutionToCtx(subst, ctx) {
  return mapEnv(ctx, (function (param) {
                return applySubstitutionToType(subst, param);
              }));
}

function varBind(name, t) {
  var exit = 0;
  switch (t.tag | 0) {
    case 1 : 
        if (t[0] === name) {
          return /* Ok */Block.__(0, [Belt_MapString.empty]);
        } else {
          return /* Ok */Block.__(0, [Belt_MapString.set(Belt_MapString.empty, name, t)]);
        }
    case 0 : 
    case 2 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    if (contains(t, name)) {
      return /* Err */Block.__(1, [/* CircularReference */Block.__(0, [toString(t)])]);
    } else {
      return /* Ok */Block.__(0, [Belt_MapString.set(Belt_MapString.empty, name, t)]);
    }
  }
  
}

function compose(s1, s2) {
  var __x = Belt_MapString.map(s2, (function (type_) {
          return applySubstitutionToType(s1, type_);
        }));
  return Belt_MapString.merge(s1, __x, (function (_, _$1, t2) {
                return t2;
              }));
}

function unify(t1, t2) {
  var exit = 0;
  switch (t1.tag | 0) {
    case 0 : 
        switch (t2.tag | 0) {
          case 0 : 
              if (t1[0] === t2[0]) {
                return /* Ok */Block.__(0, [Belt_MapString.empty]);
              } else {
                exit = 1;
              }
              break;
          case 1 : 
              return varBind(t2[0], t1);
          case 2 : 
              exit = 1;
              break;
          
        }
        break;
    case 1 : 
        return varBind(t1[0], t2);
    case 2 : 
        var f1 = t1[0];
        switch (t2.tag | 0) {
          case 0 : 
              exit = 1;
              break;
          case 1 : 
              return varBind(t2[0], t1);
          case 2 : 
              var f2 = t2[0];
              var err = unify(f1[/* from */0], f2[/* from */0]);
              if (err.tag) {
                return err;
              } else {
                var s1 = err[0];
                var err$1 = unify(applySubstitutionToType(s1, f1[/* to_ */1]), applySubstitutionToType(s1, f2[/* to_ */1]));
                if (err$1.tag) {
                  return err$1;
                } else {
                  return /* Ok */Block.__(0, [compose(s1, err$1[0])]);
                }
              }
          
        }
        break;
    
  }
  if (exit === 1) {
    return /* Err */Block.__(1, [/* TypeMismatch */Block.__(1, ["Type mismatch:\n    Expected " + (toString(t1) + ("}\n    Found " + toString(t2)))])]);
  }
  
}

var Substitution = /* module */[
  /* empty */Belt_MapString.empty,
  /* get */Belt_MapString.get,
  /* toString */toString$1,
  /* applySubstitutionToType */applySubstitutionToType,
  /* applySubstitutionToCtx */applySubstitutionToCtx,
  /* varBind */varBind,
  /* compose */compose,
  /* unify */unify
];

function infer(ctx, e) {
  switch (e.tag | 0) {
    case 0 : 
        return /* Ok */Block.__(0, [/* tuple */[
                    /* Named */Block.__(0, ["Float"]),
                    Belt_MapString.empty
                  ]]);
    case 1 : 
        return /* Ok */Block.__(0, [/* tuple */[
                    /* Named */Block.__(0, ["String"]),
                    Belt_MapString.empty
                  ]]);
    case 2 : 
        var name = e[0];
        var match = Belt_MapString.get(ctx[/* env */1], name);
        if (match) {
          return /* Ok */Block.__(0, [/* tuple */[
                      match[0],
                      Belt_MapString.empty
                    ]]);
        } else {
          return /* Err */Block.__(1, [/* UnboundVariable */Block.__(2, [name])]);
        }
    case 3 : 
        var match$1 = e[0];
        var newTVar$1 = newTVar(ctx);
        var newCtx = newBinding(ctx, match$1[/* param */0], newTVar$1);
        var __x = infer(newCtx, match$1[/* body */1]);
        return map(__x, (function (param) {
                      var subst = param[1];
                      return /* tuple */[
                              /* Fun */Block.__(2, [/* record */[
                                    /* from */applySubstitutionToType(subst, newTVar$1),
                                    /* to_ */param[0]
                                  ]]),
                              subst
                            ];
                    }));
    case 4 : 
        var match$2 = e[0];
        var err = infer(ctx, match$2[/* fn */0]);
        if (err.tag) {
          return err;
        } else {
          var match$3 = err[0];
          var s1 = match$3[1];
          var fnType = match$3[0];
          var err$1 = infer(applySubstitutionToCtx(s1, ctx), match$2[/* arg */1]);
          if (err$1.tag) {
            return err$1;
          } else {
            var match$4 = err$1[0];
            var argType = match$4[0];
            var s3 = compose(s1, match$4[1]);
            var tvar = newTVar(ctx);
            var s4 = unify(/* Fun */Block.__(2, [/* record */[
                      /* from */argType,
                      /* to_ */tvar
                    ]]), fnType);
            var fnType$prime = map(s4, (function (s4) {
                    return applySubstitutionToType(s4, fnType);
                  }));
            var __x$1 = map2(s4, fnType$prime, (function (s4, fnType$prime) {
                    return /* tuple */[
                            s4,
                            fnType$prime
                          ];
                  }));
            return andThen(__x$1, (function (param) {
                          var fnType$prime = param[1];
                          var exit = 0;
                          switch (fnType$prime.tag | 0) {
                            case 0 : 
                            case 1 : 
                                exit = 1;
                                break;
                            case 2 : 
                                var match = fnType$prime[0];
                                var to_ = match[/* to_ */1];
                                var s5 = compose(s3, param[0]);
                                var __x = applySubstitutionToType(s5, match[/* from */0]);
                                var s6 = unify(__x, argType);
                                var s7 = map(s6, (function (s6) {
                                        return compose(s5, s6);
                                      }));
                                return map(s7, (function (s7) {
                                              return /* tuple */[
                                                      applySubstitutionToType(s7, to_),
                                                      s7
                                                    ];
                                            }));
                            
                          }
                          if (exit === 1) {
                            return /* Err */Block.__(1, [/* UnexpectedError */Block.__(3, [toString(fnType) + (" substitution didn't return a Type.Fun. Returned " + toString(fnType$prime))])]);
                          }
                          
                        }));
          }
        }
    case 5 : 
        return /* Err */Block.__(1, [/* NotImplemented */0]);
    
  }
}

var TypeCheck = /* module */[
  /* Map */0,
  /* Context */Context,
  /* Substitution */Substitution,
  /* infer */infer
];

function test(ctx, ast) {
  var res = infer(ctx, ast);
  if (res.tag) {
    var err = res[0];
    if (typeof err === "number") {
      console.log("Feature not implemented");
      return /* () */0;
    } else {
      switch (err.tag | 0) {
        case 0 : 
            console.log("Circular reference: ", err[0]);
            return /* () */0;
        case 1 : 
            console.log("Type mismatch: ", err[0]);
            return /* () */0;
        case 2 : 
            console.log("Unbound variable:", err[0]);
            return /* () */0;
        case 3 : 
            console.log("Unexpected error:", err[0]);
            return /* () */0;
        
      }
    }
  } else {
    var match = res[0];
    console.log("Success", toString(match[0]), "\n" + toString$1(match[1]));
    return /* () */0;
  }
}

function ctx() {
  return /* record */[
          /* nextTVar */0,
          /* env */Belt_MapString.fromArray(/* array */[
                /* tuple */[
                  "+",
                  /* Fun */Block.__(2, [/* record */[
                        /* from : Named */Block.__(0, ["Float"]),
                        /* to_ : Fun */Block.__(2, [/* record */[
                              /* from : Named */Block.__(0, ["Float"]),
                              /* to_ : Named */Block.__(0, ["Float"])
                            ]])
                      ]])
                ],
                /* tuple */[
                  "++",
                  /* Fun */Block.__(2, [/* record */[
                        /* from : Named */Block.__(0, ["String"]),
                        /* to_ : Fun */Block.__(2, [/* record */[
                              /* from : Named */Block.__(0, ["String"]),
                              /* to_ : Named */Block.__(0, ["String"])
                            ]])
                      ]])
                ],
                /* tuple */[
                  "String.length",
                  /* Fun */Block.__(2, [/* record */[
                        /* from : Named */Block.__(0, ["String"]),
                        /* to_ : Named */Block.__(0, ["Float"])
                      ]])
                ]
              ])
        ];
}

test(ctx(/* () */0), /* Fn */Block.__(3, [/* record */[
          /* param */"x",
          /* body : Call */Block.__(4, [/* record */[
                /* fn : Var */Block.__(2, ["f"]),
                /* arg : Var */Block.__(2, ["x"])
              ]])
        ]]));

test(ctx(/* () */0), /* Fn */Block.__(3, [/* record */[
          /* param */"x",
          /* body : Call */Block.__(4, [/* record */[
                /* fn : Var */Block.__(2, ["+"]),
                /* arg : Var */Block.__(2, ["x"])
              ]])
        ]]));

test(ctx(/* () */0), /* Fn */Block.__(3, [/* record */[
          /* param */"x",
          /* body : Fn */Block.__(3, [/* record */[
                /* param */"y",
                /* body : Call */Block.__(4, [/* record */[
                      /* fn : Var */Block.__(2, ["+"]),
                      /* arg : Var */Block.__(2, ["x"])
                    ]])
              ]])
        ]]));

test(ctx(/* () */0), /* Fn */Block.__(3, [/* record */[
          /* param */"s",
          /* body : Call */Block.__(4, [/* record */[
                /* fn : Var */Block.__(2, ["String.length"]),
                /* arg : Var */Block.__(2, ["s"])
              ]])
        ]]));

test(ctx(/* () */0), /* Fn */Block.__(3, [/* record */[
          /* param */"x",
          /* body : Call */Block.__(4, [/* record */[
                /* fn : Call */Block.__(4, [/* record */[
                      /* fn : Var */Block.__(2, ["+"]),
                      /* arg : Var */Block.__(2, ["x"])
                    ]]),
                /* arg : Float */Block.__(0, [5])
              ]])
        ]]));

exports.Result = Result;
exports.Ast = Ast;
exports.Type = Type;
exports.TypeCheck = TypeCheck;
exports.test = test;
exports.ctx = ctx;
/*  Not a pure module */
